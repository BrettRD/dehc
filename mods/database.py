'''The module containing objects that manage the CouchDB database.'''

import datetime
import json
import random

from ibmcloudant import CouchDbSessionAuthenticator
from ibmcloudant.cloudant_v1 import CloudantV1, BulkDocs, Document, IndexDefinition, IndexField

# ----------------------------------------------------------------------------

class Database:
    '''A class which enables communication with a CouchDB database.
    
    This class is application agnostic and only performs basic operations. For helper methods specific to the DEHC application, use the DEHCDatabase class down below.
    
    client: The Cloudant-CouchDB client object.
    loud: If true, database transactions will be logged to console.
    '''

    def __init__(self, config: str, loud: bool = False):
        '''Constructs a Database object.
        
        config: Path to .json file containing database server credentials.
        loud: If true, database transactions will be logged to console.
        '''
        with open(config, "r") as f:
            data = json.loads(f.read())
        auth = CouchDbSessionAuthenticator(username=data['user'], password=data['pass'])
        self.client = CloudantV1(authenticator=auth)
        self.client.set_service_url(data['url'])
        self.loud = loud


    def database_create(self, dbname: str):
        '''Creates a new database.
        
        dbname: Name of the database to create.
        '''
        self.client.put_database(db=dbname)
        self._log(f"New db {dbname}")


    def database_delete(self, dbname: str):
        '''Deletes an existing database.
        
        dbname: Name of the database to delete.
        '''
        self.client.delete_database(db=dbname)
        self._log(f"Del db {dbname}")


    def database_exists(self, dbname: str):
        '''Returns whether or not a database exists.
        
        dbname: Name of the database to check.
        '''
        try:
            response = self.client.get_database_information(db=dbname).get_status_code()
            if response == 200:
                return True
            else:
                return False
        except:
            return False


    def database_list(self):
        '''Returns a list of active databases.'''
        return self.client.get_all_dbs().get_result()


    def document_create(self, dbname: str, doc: dict, id: str = None):
        '''Creates a new document, returning its id.
        
        dbname: Name of database to create document in.
        doc: The contents of the document.
        id: The UUID of the document. If omitted, one is generated by CouchDB.
        '''
        doc = Document(id=self.id_get()[0], **doc) if id == None else Document(id=id, **doc)
        res = self.client.post_document(db=dbname, document=doc).get_result()
        id = res['id']
        self._log(f"New doc {dbname} {id}")
        return id


    def document_delete(self, dbname: str, id: str):
        '''Deletes an existing document.
        
        dbname: Name of database to delete document in.
        id: The UUID of document to delete.
        '''
        doc = self.client.get_document(db=dbname, doc_id=id).get_result()
        res = self.client.delete_document(db=dbname, doc_id=id, rev=doc["_rev"]).get_result()
        self._log(f"Del doc {dbname} {res['id']}")


    def document_edit(self, dbname: str, doc: dict, id: str):
        '''Edits an existing document.
        
        dbname: Name of database to edit document in.
        doc: Fields and values to be edited.
        id: The UUID of the document to edit.
        '''
        remote_doc = self.client.get_document(db=dbname, doc_id=id).get_result()
        remote_doc.update(doc)
        res = self.client.post_document(db=dbname, document=remote_doc).get_result()
        self._log(f"Edit doc {dbname} {res['id']}")


    def document_exists(self, dbname: str, id: str):
        '''Returns whether or not a document exists.
        
        dbname: Name of database to look in.
        id: The UUID of document to look for.
        '''
        try:
            response = self.client.head_document(db=dbname, doc_id=id).get_status_code()
            if response == 200:
                return True
            return False
        except:
            return False


    def document_get(self, dbname: str, id: str):
        '''Retrieves a document from a database and returns it.
        
        dbname: Name of database to fetch from.
        id: The UUID of document to fetch.
        '''
        remote_doc = self.client.get_document(db=dbname, doc_id=id).get_result()
        return remote_doc


    def document_list(self, dbname: str, limit: int = 25):
        '''Returns a list of all documents in a database. Intensive!
        
        dbname: Name of database to fetch all docs from.
        limit: Number of docs to retrieve. Set arbitrary large to fetch all.
        '''
        remote_docs = self.client.post_all_docs(db=dbname, include_docs=True, limit=limit).get_result()
        return remote_docs


    def documents_create(self, dbname: str, docs: list, ids: list):
        '''Creates multiple documents at once, returning their ids.
        
        dbname: Name of database to create documents in.
        doc: A list of the contents of each document.
        ids: A list of UUIDs of the documents. If omitted, they are generated by CouchDB.
        '''
        doc_list = []
        if ids == None:
            for doc in docs:
                doc = Document(id=self.id_get()[0], **doc)
                doc_list.append(doc)
        else:
            for index, doc in enumerate(docs):
                doc = Document(id=ids[index], **doc)
                doc_list.append(doc)

        doc_list = BulkDocs(docs=doc_list)
        res = self.client.post_bulk_docs(db=dbname, bulk_docs=doc_list).get_result()
        ids = []
        for re in res:
            id = re['id']
            self._log(f"New doc {dbname} {id}")
            ids.append(id)
        return ids


    def documents_delete(self, dbname: str, ids: str):
        '''Deletes multiple documents at once.
        
        dbname: Name of database to delete documents in.
        ids: The UUIDs of the documents to delete.
        '''
        for id in ids:
            doc = self.client.get_document(db=dbname, doc_id=id).get_result()
            res = self.client.delete_document(db=dbname, doc_id=id, rev=doc["_rev"]).get_result()
            self._log(f"Del doc {dbname} {res['id']}")


    def documents_edit(self, dbname: str, docs: list, ids: list):
        '''Edits multiple documents at once, returning a list of id and rev numbers. 
        
        dbname: Name of database to edit documents in.
        docs: Lists of fields and values to be edited.
        ids:  List of IDs of documents being edited.
        '''
        remote_docs = self.client.post_all_docs(db=dbname, include_docs=True, limit=len(ids), keys=ids).get_result()
        doc_list = []
        for remote_doc in remote_docs['rows']:
            remote_doc = remote_doc['doc']
            id = remote_doc["_id"]
            rev = remote_doc["_rev"]
            remote_doc.update(docs[ids.index(id)])
            remote_doc = Document(id=id, rev=rev, **remote_doc)
            doc_list.append(remote_doc)

        doc_list = BulkDocs(docs=doc_list)
        res = self.client.post_bulk_docs(db=dbname, bulk_docs=doc_list).get_result()
        for re in res:
            self._log(f"Edit doc {dbname} {re['id']}")


    def documents_get(self, dbname: str, ids: str):
        '''Retrieves multiple documents and returns them.
        
        dbname:  Name of database to get documents from.
        ids: A list of UUIDs of documents to fetch.
        '''
        remote_docs = self.client.post_all_docs(db=dbname, include_docs=True, limit=len(ids), keys=ids).get_result()
        res = [doc['doc'] for doc in remote_docs['rows']]
        return res


    def id_create(self, n: int = 1, length: int = 12, prefix: str = ""):
        '''Generates new UUIDs within Python and returns them.
        
        n: The number of UUIDs to create.
        length: The length of the UUID's hex component.
        prefix: Prefix for the UUID.
        '''
        ids = []
        for _ in range(0, n):
            hexstr = hex(random.randint(0, 16 ** length))[2:]
            id = prefix + "0" * (length - len(hexstr)) + hexstr
            ids.append(id)
        return ids


    def id_get(self, n: int = 1, prefix: str = ""):
        '''Retrieves new UUIDs from CouchDB and returns them.
        
        prefix: Prefix to add to the UUID.
        '''
        response = self.client.get_uuids(count=n).get_result()['uuids']
        for index, id in enumerate(response):
            response[index] = prefix+id
        return response


    def index_create(self, dbname: str, name: str, fields: list):
        '''Creates a new MongoDB-style index and returns its id (name).
        
        dbname = Name of database to index.
        name = Name of the index. Also used as design doc's name.
        fields = List of dictionaries of form {"FIELDNAME" : "asc" | "desc"}, defining the index.
        '''
        index_field_list = []
        for field in fields:
            index_field_list.append(IndexField(**field))
        index_definition = IndexDefinition(fields=index_field_list)
        res = self.client.post_index(db=dbname, index=index_definition, ddoc=name, name=name, type="json").get_result()
        id = res['id'][8:]
        self._log(f"New idx {dbname} {id}")
        return id


    def index_delete(self, dbname: str, name: str):
        '''Deletes an existing MongoDB-style index.

        dbname = Name of database index is stored in.
        name = Name of the index to be deleted.
        '''
        self.client.delete_index(db=dbname, ddoc=name, type="json", index=name)
        self._log(f"Del idx {dbname} {name}")


    def index_exists(self, dbname: str, name: str):
        '''Returns whether or not a MongoDB-style index exists.
        
        dbname = Name of database index is stored in.
        name = Name of the index to be checked.
        '''
        try:
            response = self.client.head_design_document(db=dbname, ddoc=name).get_status_code()
            if response == 200:
                return True
            return False
        except:
            return False


    def query(self, dbname: str, selector: dict, fields: list, sort: list, limit: int = 25):
        '''Queries a database using MongoDB-style selectors & indexes.
        
        An index involving the 'sort' fields must exist, otherwise the query will fail.
        For selector operators, see: https://docs.mongodb.com/manual/reference/operator/query/

        db = Name of database being queried.
        selector = A MongoDB style selector: {"FIELDNAME" : {"OPERATOR": "VALUE"}, ... }
        fields = List of fields to return: ["FIELD1", "FIELD2", ...]
        sort = List defining sort order: [{"FIELD1": "ASC"}, {"FIELD2": "DESC"}, ...]
        limit = Number of docs to retrieve. Set arbitrary large to fetch all.
        '''
        res = self.client.post_find(db=dbname, selector=selector, fields=fields, sort=sort, limit=limit).get_result()
        return res['docs']


    def server_check(self):
        '''Returns whether or not the CouchDB server is accessible.'''
        try:
            response = self.client.get_up_information().get_result()
            if response['status'] == 'ok':
                return True
            return False
        except:
            return False


    def _log(self, msg: str):
        '''Logs a timestamped message to the console.
        
        msg: Message to log.
        '''
        if self.loud == True:
            ts = datetime.datetime.now(datetime.timezone.utc)
            ts = f"{ts.year}-{ts.month:02d}-{ts.day:02d} {ts.hour:02d}:{ts.minute:02d}:{ts.second:02d}"
            if self.loud == True:
                print(f"{ts} | {msg}")


# ----------------------------------------------------------------------------

class DEHCDatabase:
    '''A class which handles database transactions in DEHC applications.
    
    This class is specific to DEHC and is the one to import into the apps. Importing the Database class up above should not be necessary.
    
    database: The associated Database object.
    db_list: List of DEHC database names.
    schema: Dictionary describing objects and fields in the database.
    '''

    def __init__(self, config: str, loud: bool = False):
        '''Constructs a DEHCDatabase object.

        config: Path to .json file containing database server credentials.
        loud: If true, database transactions will be logged to console.
        '''
        self.db = Database(config=config, loud=loud)
        self.db_list = ["items", "flags", "containers", "files", "logs"]
        self.schema = {}
    

    def databases_create(self):
        '''Creates DEHC databases if they don't already exist.'''
        for db in self.db_list:
            if self.db.database_exists(db) == False:
                self.db.database_create(db)
    
    
    def databases_delete(self):
        '''Deletes DEHC databases if they exist.'''
        for db in self.db_list:
            if self.db.database_exists(db) == True:
                self.db.database_delete(db)
    

# ----------------------------------------------------------------------------