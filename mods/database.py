'''The module containing objects that manage the CouchDB database.'''

import datetime
import json
import random

from ibmcloudant import CouchDbSessionAuthenticator
from ibmcloudant.cloudant_v1 import CloudantV1, BulkDocs, Document, IndexDefinition, IndexField

# ----------------------------------------------------------------------------

class Database:
    '''A class which enables communication with a CouchDB database.
    
    This class is application agnostic and only performs basic operations. 
    For helper methods specific to the DEHC application, use the DEHCDatabase 
    class down below.
    
    client: The Cloudant-CouchDB client object.
    loud: If true, database transactions will be logged to console.
    '''

    def __init__(self, config: str, loud: bool = False):
        '''Constructs a Database object.
        
        config: Path to .json file containing database server credentials.
        loud: If true, database transactions will be logged to console.
        '''
        with open(config, "r") as f:
            data = json.loads(f.read())
        auth = CouchDbSessionAuthenticator(username=data['user'], 
        password=data['pass'])
        self.client = CloudantV1(authenticator=auth)
        self.client.set_service_url(data['url'])
        self.loud = loud
        self._log("start")


    def database_create(self, dbname: str):
        '''Creates a new database.
        
        dbname: Name of the database to create.
        '''
        self.client.put_database(db=dbname)
        self._log(f"new db {dbname}")


    def database_delete(self, dbname: str):
        '''Deletes an existing database.
        
        dbname: Name of the database to delete.
        '''
        self.client.delete_database(db=dbname)
        self._log(f"del db {dbname}")


    def database_exists(self, dbname: str):
        '''Returns whether or not a database exists.
        
        dbname: Name of the database to check.
        '''
        try:
            response = self.client.get_database_information(db=dbname).get_status_code()
            if response == 200:
                self._log(f"db {dbname} exists")
                return True
            else:
                self._log(f"db {dbname} does not exist")
                return False
        except:
            self._log(f"db {dbname} does not exist")
            return False


    def database_list(self):
        '''Returns a list of active databases.'''
        self._log(f"list db")
        return self.client.get_all_dbs().get_result()


    def document_create(self, dbname: str, doc: dict, id: str = None):
        '''Creates a new document, returning its id.
        
        dbname: Name of database to create document in.
        doc: The contents of the document.
        id: The UUID of the document. If omitted, one is generated by CouchDB.
        '''
        doc = Document(id=self.id_get()[0], **doc) if id == None else Document(id=id, **doc)
        res = self.client.post_document(db=dbname, document=doc).get_result()
        id = res['id']
        self._log(f"new doc {dbname} {id}")
        return id


    def document_delete(self, dbname: str, id: str, lazy: bool = False):
        '''Deletes an existing document.
        
        dbname: Name of database to delete document in.
        id: The UUID of document to delete.
        lazy: If true, won't error if document doesn't exist.
        '''
        if lazy == False or self.document_exists(dbname=dbname, id=id) == True:
            doc = self.client.get_document(db=dbname, doc_id=id).get_result()
            self.client.delete_document(db=dbname, doc_id=id, rev=doc["_rev"])
            self._log(f"del doc {dbname} {id}")
        else:
            self._log(f"del doc {dbname} {id} failed")


    def document_edit(self, dbname: str, doc: dict, id: str, lazy: bool = False):
        '''Edits an existing document.
        
        dbname: Name of database to edit document in.
        doc: Fields and values to be edited.
        id: The UUID of the document to edit.
        lazy: If true, won't error if document doesn't exist.
        '''
        if lazy == False or self.document_exists(dbname="items", id=id) == True:
            remote_doc = self.client.get_document(db=dbname, doc_id=id).get_result()
            remote_doc.update(doc)
            self.client.post_document(db=dbname, document=remote_doc)
            self._log(f"Edit doc {dbname} {id}")
        else:
            self._log(f"Edit doc {dbname} {id} failed")


    def document_exists(self, dbname: str, id: str):
        '''Returns whether or not a document exists.
        
        dbname: Name of database to look in.
        id: The UUID of document to look for.
        '''
        try:
            response = self.client.head_document(db=dbname, doc_id=id).get_status_code()
            if response == 200:
                self._log(f"doc {dbname} {id} exists")
                return True
            self._log(f"doc {dbname} {id} does not exist")
            return False
        except:
            self._log(f"doc {dbname} {id} does not exist")
            return False


    def document_get(self, dbname: str, id: str, lazy: bool = False):
        '''Retrieves a document from a database and returns it.
        
        dbname: Name of database to fetch from.
        id: The UUID of document to fetch.
        lazy: If true, won't error if document doesn't exist.
        '''
        if lazy == False or self.document_exists(dbname="items", id=id) == True:
            remote_doc = self.client.get_document(db=dbname, doc_id=id).get_result()
            self._log(f"get doc {dbname} {id}")
        else:
            remote_doc = {}
            self._log(f"get doc {dbname} {id} failed")
        return remote_doc


    def documents_create(self, dbname: str, docs: list, ids: list):
        '''Creates multiple documents at once, returning their ids.
        
        dbname: Name of database to create documents in.
        doc: A list of the contents of each document.
        ids: A list of UUIDs of the documents. If omitted, they are generated by CouchDB.
        '''
        doc_list = []
        if ids == None:
            for doc in docs:
                doc = Document(id=self.id_get()[0], **doc)
                doc_list.append(doc)
        else:
            for index, doc in enumerate(docs):
                doc = Document(id=ids[index], **doc)
                doc_list.append(doc)

        doc_list = BulkDocs(docs=doc_list)
        res = self.client.post_bulk_docs(db=dbname, bulk_docs=doc_list).get_result()
        ids = []
        for re in res:
            id = re['id']
            self._log(f"bulk new doc {dbname} {id}")
            ids.append(id)
        return ids


    def documents_delete(self, dbname: str, ids: str, lazy: bool = False):
        '''Deletes multiple documents at once.
        
        dbname: Name of database to delete documents in.
        ids: The UUIDs of the documents to delete.
        lazy: If true, won't error if any documents doesn't exist.
        '''
        remote_docs = self.client.post_all_docs(db=dbname, limit=len(ids), keys=ids).get_result()['rows']
        for remote_doc in remote_docs:
            id = remote_doc["key"]
            if lazy == False or self.document_exists(dbname=dbname, id=id) == True:
                rev = remote_doc["value"]["rev"]
                self.client.delete_document(db=dbname, doc_id=id, rev=rev)
                self._log(f"bulk del doc {dbname} {id}")
            else:
                self._log(f"bulk del doc {dbname} {id} failed")


    def documents_edit(self, dbname: str, docs: list, ids: list, lazy: bool = False):
        '''Edits multiple documents at once, returning a list of id and rev numbers. 
        
        dbname: Name of database to edit documents in.
        docs: Lists of fields and values to be edited.
        ids:  List of IDs of documents being edited.
        lazy: If true, won't error if any documents doesn't exist.
        '''
        remote_docs = self.client.post_all_docs(db=dbname, include_docs=True, limit=len(ids), keys=ids).get_result()['rows']
        doc_list = []
        for remote_doc in remote_docs:
            id = remote_doc["key"]
            if lazy == False or self.document_exists(dbname=dbname, id=id) == True:
                rev = remote_doc["value"]["rev"]
                remote_doc = remote_doc['doc']
                remote_doc.update(docs[ids.index(id)])
                remote_doc = Document(id=id, rev=rev, **remote_doc)
                doc_list.append(remote_doc)
            else:
                self._log(f"bulk edit doc {dbname} {id} failed")

        doc_list = BulkDocs(docs=doc_list)
        res = self.client.post_bulk_docs(db=dbname, bulk_docs=doc_list).get_result()
        for re in res:
            self._log(f"bulk edit doc {dbname} {re['id']}")


    def documents_get(self, dbname: str, ids: str, lazy: bool = False):
        '''Retrieves multiple documents and returns them.
        
        dbname:  Name of database to get documents from.
        ids: A list of UUIDs of documents to fetch.
        lazy: If true, won't error if any documents don't exist.
        '''
        remote_docs = self.client.post_all_docs(db=dbname, include_docs=True, limit=len(ids), keys=ids).get_result()['rows']
        doc_list = []
        for doc in remote_docs:
            id = doc["key"]
            if lazy == False or self.document_exists(dbname=dbname, id=id) == True:
                self._log(f"bulk get doc {dbname} {id}")
                doc_list.append(doc['doc'])
            else:
                self._log(f"bulk get doc {dbname} {id} failed")
        return doc_list


    def documents_list(self, dbname: str, startkey: str = None, endkey: str = None, limit: int = 25):
        '''Returns a list of all documents in a database. Intensive!
        
        dbname: Name of database to fetch all docs from.
        startkey: If included, document UUID to start fetching from.
        endkey: If included, document UUID to stop fetching at.
        limit: Number of docs to retrieve. Set arbitrary large to fetch all.
        '''
        remote_docs = self.client.post_all_docs(db=dbname, include_docs=True, startkey=startkey, endkey=endkey, limit=limit).get_result()
        docs = []
        for remote_doc in remote_docs['rows']:
            docs.append(remote_doc['doc'])
        self._log(f"list doc {dbname} {startkey if startkey != None else 'START'} to {endkey if endkey != None else 'END'}")
        return docs


    def id_create(self, n: int = 1, length: int = 12, prefix: str = ""):
        '''Generates new UUIDs within Python and returns them.
        
        n: The number of UUIDs to create.
        length: The length of the UUID's hex component.
        prefix: Prefix for the UUID.
        '''
        ids = []
        for _ in range(0, n):
            hexstr = hex(random.randint(0, 16 ** length))[2:]
            id = prefix + "0" * (length - len(hexstr)) + hexstr
            ids.append(id)
        return ids


    def id_get(self, n: int = 1, prefix: str = ""):
        '''Retrieves new UUIDs from CouchDB and returns them.
        
        prefix: Prefix to add to the UUID.
        '''
        response = self.client.get_uuids(count=n).get_result()['uuids']
        for index, id in enumerate(response):
            response[index] = prefix+id
        return response


    def index_create(self, dbname: str, name: str, fields: list):
        '''Creates a new MongoDB-style index and returns its id (name).
        
        dbname = Name of database to index.
        name = Name of the index. Also used as design doc's name.
        fields = List of dictionaries of form {"FIELDNAME" : "asc" | "desc"}, defining the index.
        '''
        index_field_list = []
        for field in fields:
            index_field_list.append(IndexField(**field))
        index_definition = IndexDefinition(fields=index_field_list)
        res = self.client.post_index(db=dbname, index=index_definition, ddoc=name, name=name, type="json").get_result()
        id = res['id'][8:]
        self._log(f"new idx {dbname} {id}")
        return id


    def index_delete(self, dbname: str, name: str):
        '''Deletes an existing MongoDB-style index.

        dbname = Name of database index is stored in.
        name = Name of the index to be deleted.
        '''
        self.client.delete_index(db=dbname, ddoc=name, type="json", index=name)
        self._log(f"del idx {dbname} {name}")


    def index_exists(self, dbname: str, name: str):
        '''Returns whether or not a MongoDB-style index exists.
        
        dbname = Name of database index is stored in.
        name = Name of the index to be checked.
        '''
        try:
            response = self.client.head_design_document(db=dbname, ddoc=name).get_status_code()
            if response == 200:
                self._log(f"idx {dbname} {name} exists")
                return True
            self._log(f"idx {dbname} {name} does not exist")
            return False
        except:
            self._log(f"idx {dbname} {name} does not exist")
            return False


    def query(self, dbname: str, selector: dict = {}, fields: list = None, sort: list = None, limit: int = 25):
        '''Queries a database using MongoDB-style selectors & indexes.
        
        An index involving the 'sort' fields must exist, otherwise the query will fail.
        For selector operators, see: https://docs.mongodb.com/manual/reference/operator/query/

        db = Name of database being queried.
        selector = A MongoDB style selector: {"FIELDNAME" : {"OPERATOR": "VALUE"}, ... }. If omitted, returns no documents.
        fields = List of fields to return: ["FIELD1", "FIELD2", ...]. If omitted, returns all fields.
        sort = List defining sort order: [{"FIELD1": "ASC"}, {"FIELD2": "DESC"}, ...]. If omitted, returns in ascending UUID order.
        limit = Number of docs to retrieve. Set arbitrary large to fetch all.
        '''
        res = self.client.post_find(db=dbname, selector=selector, fields=fields, sort=sort, limit=limit).get_result()
        self._log(f"query {dbname} where {selector} for {fields} sort {sort}")
        return res['docs']


    def server_check(self):
        '''Returns whether or not the CouchDB server is accessible.'''
        try:
            response = self.client.get_up_information().get_result()
            if response['status'] == 'ok':
                return True
            return False
        except:
            return False


    def _log(self, msg: str):
        '''Logs a timestamped message to the console.
        
        msg: Message to log.
        '''
        if self.loud == True:
            ts = datetime.datetime.now(datetime.timezone.utc)
            ts = f"{ts.year}-{ts.month:02d}-{ts.day:02d} {ts.hour:02d}:{ts.minute:02d}:{ts.second:02d}"
            if self.loud == True:
                print(f"{ts} | {msg}")


    def __del__(self):
        self._log("end")


# ----------------------------------------------------------------------------

class DEHCDatabase:
    '''A class which handles database transactions in DEHC applications.
    
    This class is specific to DEHC and is the one to import into the apps. 
    Importing the Database class up above should not be necessary.
    
    database: The associated Database object.
    db_list: List of DEHC database names.
    id_len: Length of hex part of document UUIDs used in the database.
    limit: Max number of documents to return from _list and _query methods.
    schema: Dictionary describing objects and fields in the database.
    '''

    def __init__(self, *, config: str, loud: bool = False, quickstart: bool = False):
        '''Constructs a DEHCDatabase object.

        config: Path to .json file containing database server credentials.
        loud: If true, database transactions will be logged to console.
        quickstart: Creates databases and loads schema automatically.
        '''
        self.db = Database(config=config, loud=loud)

        self.db_list = ["items", "containers"]
        self.id_len = 12
        self.limit = 1000000

        self.schema = {}
        if quickstart == True:
            self.databases_create(lazy=True)
            self.schema_load(schema="db_schema.json")
            self.schema_save()


    def databases_create(self, lazy: bool = False):
        '''Creates DEHC databases.
        
        lazy: If true, won't error if databases already exist.
        '''
        for db in self.db_list:
            if lazy == False or self.db.database_exists(db) == False:
                self.db.database_create(db)
    
    
    def databases_delete(self, lazy: bool = False):
        '''Deletes DEHC databases.
        
        lazy: If true, won't error if databases don't exist.
        '''
        for db in self.db_list:
            if lazy == False or self.db.database_exists(db) == True:
                self.db.database_delete(db)


    def container_add(self, container: str, item: str, lazy: bool = False):
        '''Puts an item in a container.
        
        container: The UUID of the container.
        item: The UUID of the item.
        lazy: If true, won't error if item already in container.
        '''
        idc = container+"/"+item
        if lazy == False or self.db.document_exists(dbname="containers", id=idc) == False:
            doc = {"container": container, "child": item}
            self.db.document_create(dbname="containers", doc=doc, id=idc)
        return idc


    def container_adds(self, container: str, items: list):
        '''Puts multiple items in a container.
        
        container: The UUID of the container.
        items: The UUIDs of the items.
        '''
        ids_list = [container+"/"+item for item in items]
        docs_list = [{"container": container, "child": item} for item in items]
        self.db.documents_create(dbname="containers", ids=ids_list, docs=docs_list)
        return ids_list


    def container_children(self, container: str, cat: str = None, result: str = "ITEM"):
        '''Returns flat list, listing items contained by a container.

        container: Container to return containing items of.
        cat: If included, only returns children of this category.
        result: "ITEM" to return item ids, "CON" to return container ids, "DOC" to return item documents.
        '''
        selector = {'container': {'$eq': container}}
        fields = ['_id', 'child']
        sort = [{'container': 'asc'}, {'child': 'asc'}]
        query = self.containers_query(selector=selector, fields=fields, sort=sort)
        if result == "CON":
            children = [row['_id'] for row in query if cat == None or self.id_cat(row['child']) == cat]
        elif result == "ITEM" or result == "DOC":
            children = [row['child'] for row in query if cat == None or self.id_cat(row['child']) == cat]
            if result == "DOC":
                children = self.db.documents_get(dbname="items", ids=children)
        else:
            raise ValueError("result should be one of ITEM, CON or DOC")
        return children


    def container_children_all(self, container: str, cat: str = None, result: str = "ITEM"):
        '''Returns flat list, listing items contained by a container and its sub-containers, recursively.

        container: Container to return containing items of.
        cat: If included, only returns children of this category.
        result: "ITEM" to return item ids, "CON" to return container ids, "DOC" to return item documents.
        '''
        return self.containers_children_all(containers=[container], cat=cat, result=result)


    def container_children_all_dict(self, container: str, cat: str = None):
        '''Returns nested dictionary, listing items contained by a container and all sub-containers, recursively.
    
        container: Container to return containing items of.
        cat: If included, only returns children of this category.
        '''
        return self.containers_children_all_dict(containers=[container], cat=cat)


    def container_children_dict(self, container: str, cat: str = None):
        '''Returns dictionary, listing items contained by a container.

        container: Container to return containing items of.
        cat: If included, only returns children of this category.
        '''
        children = {container: self.container_children(container=container, cat=cat)}
        return children


    def container_exists(self, container: str, item: str):
        '''Returns whether or not a container-item relationship exists.
        
        container: The UUID of container to check.
        item: The UUID of item to check.
        '''
        idc = container+"/"+item
        return self.db.document_exists(dbname="containers", id=idc)


    def container_flag(self, container: str, flag: str, value: int, lazy: bool = False):
        '''Sets a flag for every child of a container to a particular value.
        
        container: Container to set flag for.
        flag: Flag to set.
        value: Numerical value to set flag to.
        lazy: If true, won't error if container or containing items don't exist.
        '''
        items = [container]+self.container_children_all(container=container, result="ITEM")
        self.items_flag(items=items, flag=flag, value=value, lazy=lazy)


    def container_flag_get(self, container: str, flag: str, lazy: bool = False):
        '''Retrieves the highest value of a flag among an item and its children.
        
        container: Container to check for flag.
        flag: Flag to check for.
        lazy: If true, won't error if container or containing items don't exist.
        '''
        items = [container]+self.container_children_all(container=container, result="ITEM")
        return self.flags_get(items=items, flag=flag, lazy=lazy)


    def container_move(self, from_con: str, to_con: str, item: str, lazy: bool = False):
        '''Moves an item from one container to another.
        
        from_con: The UUID of the container the item is leaving.
        to_con: The UUID of the container the item is entering.
        item: The UUID of the item.
        lazy: If true, won't error if from_con doesn't exist, or to_con already exists.
        '''
        self.container_add(container=to_con, item=item, lazy=lazy)
        self.container_remove(container=from_con, item=item, lazy=lazy)


    def container_moves(self, from_con: str, to_con: str, items: list, lazy: bool = False):
        '''Moves multiple items from one container to another.
        
        from_con: The UUID of the container the item is leaving.
        to_con: The UUID of the container the item is entering.
        items: The UUIDs of the items.
        lazy: If true, won't error if from_con doesn't exist, or to_con already exists.
        '''
        self.container_adds(container=to_con, items=items)
        self.container_removes(container=from_con, items=items, lazy=lazy)


    def container_remove(self, container: str, item: str, lazy: bool = False):
        '''Removes an item from a container.
        
        container: The UUID of the container.
        item: The UUID of the item.
        lazy: If true, won't error if container or child doesn't exist.
        '''
        id = container+"/"+item
        self.db.document_delete(dbname="containers", id=id, lazy=lazy)


    def container_removes(self, container: str, items: list, lazy: bool = False):
        '''Removes multiple items from a container.
        
        container: The UUID of the container.
        items: The UUIDs of the items.
        lazy: If true, won't error if container or child doesn't exist.
        '''
        ids = [container+"/"+item for item in items]
        self.db.documents_delete(dbname="containers", ids=ids, lazy=lazy)


    def containers_children(self, containers: list, cat: str = None, result: str = "ITEM"):
        '''Returns flat list, listing items contained by multiple containers.

        containers: Containers to return containing items of.
        cat: If included, only returns children of this category.
        result: "ITEM" to return item ids, "CON" to return container ids, "DOC" to return item documents.
        '''
        selector = {'container': {'$in': containers}}
        fields = ['_id', 'child']
        sort = [{'container': 'asc'}, {'child': 'asc'}]
        query = self.containers_query(selector=selector, fields=fields, sort=sort)
        if result == "CON":
            children = [row['_id'] for row in query if cat == None or self.id_cat(row['child']) == cat]
            children = list(dict.fromkeys(children))
        elif result == "ITEM" or result == "DOC":
            children = [row['child'] for row in query if cat == None or self.id_cat(row['child']) == cat]
            children = list(dict.fromkeys(children))
            if result == "DOC":
                children = self.db.documents_get(dbname="items", ids=children)
        else:
            raise ValueError("result should be one of ITEM, CON or DOC")
        return children


    def containers_children_all(self, containers: str, cat: str = None, result: str = "ITEM"):
        '''Returns flat list, listing items contained by some containers and all sub-containers, recursively.

        containers: Containers to return containing items of.
        cat: If included, only returns children of this category.
        result: "ITEM" to return item ids, "CON" to return container ids, "DOC" to return item documents.
        '''
        children = []
        current_containers = containers
        while True:
            ids = self.containers_children(containers=current_containers, result="ITEM")
            if len(ids) > 0:
                children += self.containers_children(containers=current_containers, result=result, cat=cat)
                current_containers = ids
            else:
                break
        return children


    def containers_children_all_dict(self, containers: list, cat: str = None):
        '''Returns nested dictionary, listing items contained by multiple containers and all sub-containers, recursively.
    
        containers: Containers to return containing items of.
        cat: If included, only returns children of this category.
        '''
        results = self.containers_children_dict(containers=containers)
        for container in containers:
            result = results[container]
            if len(result) > 0:
                result = self.containers_children_all_dict(containers=result, cat=cat)
            results[container] = result
        if cat != None:
            results_c = results.copy()
            for result in results_c:
                if len(results[result]) == 0 and self.id_cat(result) != cat:
                    del results[result]
        return results


    def containers_children_dict(self, containers: list, cat: str = None):
        '''Returns dictionary of lists, listing items contained by multiple containers.

        containers: Containers to return containing items of.
        cat: If included, only returns children of this category.
        '''
        selector = {'container': {'$in': containers}}
        fields = ['_id', 'container', 'child']
        sort = [{'container': 'asc'}, {'child': 'asc'}]
        query = self.containers_query(selector=selector, fields=fields, sort=sort)
        children = {container: [] for container in containers} 
        for row in query:
            child = row['child']
            if cat == None or self.id_cat(child) == cat:
                children[row['container']].append(child)
        return children


    def containers_flag(self, containers: list, flag: str, value: int, lazy: bool = False):
        '''Sets a flag for every child of multiple containers to a particular value.
        
        containers: Containers to set flag for.
        flag: Flag to set.
        value: Numerical value to set flag to.
        lazy: If true, won't error if container or containing items don't exist.
        '''
        items = containers+self.containers_children_all(containers=containers, result="ITEM")
        self.items_flag(items=items, flag=flag, value=value, lazy=lazy)


    def containers_flag_get(self, containers: list, flag: str, lazy: bool = False):
        '''Retrieves the highest value of a flag among multiple items and their children.
        
        containers: Containers to check for flag.
        flag: Flag to check for.
        lazy: If true, won't error if container or containing items don't exist.
        '''
        items = containers+self.containers_children_all(containers=containers, result="ITEM")
        return self.flags_get(items=items, flag=flag, lazy=lazy)


    def containers_list(self):
        '''Retrieves every doc from container database. Intensive!'''
        return self.db.documents_list(dbname="containers", limit=self.limit)


    def containers_query(self, selector: dict = {}, fields: list = None, sort: list = None):
        '''Queries the container database and returns the results.

        For selector operators, see: https://docs.mongodb.com/manual/reference/operator/query/

        selector = A MongoDB style selector: {"FIELDNAME" : {"OPERATOR": "VALUE"}, ... }. If omitted, returns all items.
        fields = List of fields to return: ["FIELD1", "FIELD2", ...]. If omitted, returns all fields.
        sort = List defining sort order: [{"FIELD1": "ASC"}, {"FIELD2": "DESC"}, ...]. If omitted, returns in ascending UUID order.
        '''
        if sort != None:
            index_name = "idx"
            for field in sort:
                key = next(iter(field.keys()))
                index_name += f"-{key}"
            if self.db.index_exists(dbname="containers", name=index_name) == False:
                self.db.index_create(dbname="containers", name=index_name, fields=sort)
        res = self.db.query(dbname="containers", selector=selector, fields=fields, sort=sort, limit=self.limit)
        return res


    def flag_get(self, item: str, flag: str, lazy: bool = False):
        '''Retrieves the value of a flag for a particular item.
        
        item: Item to check for flag.
        flag: Flag to check for.
        lazy: If true, won't error if item doesn't exist.
        '''
        doc = self.db.document_get(dbname="items", id=item, lazy=lazy)
        return doc.get(flag, 0)


    def flags_get(self, items: list, flag: str, lazy: bool = False):
        '''Retrieves the highest value of a flag among multiple items.
        
        items: Items to check for flag.
        flag: Flag to check for.
        lazy: If true, won't error if item doesn't exist.
        '''
        docs = self.db.documents_get(dbname="items", ids=items, lazy=lazy)
        return max([doc.get(flag, 0) for doc in docs])


    def id_cat(self, id: str):
        '''Takes an id and returns its category.
        
        id: The UUID to extract the category of.
        '''
        cat, *_ = id.split("/")
        return cat


    def item_create(self, cat: str, doc: dict):
        '''Creates new item in items database, returns id.
        
        cat: The item's category.
        doc: The item's data: {"field": "value", ...}
        '''
        id, = self.db.id_create(length=self.id_len, prefix=cat+"/")
        doc['category'] = cat
        self.db.document_create(dbname="items", doc=doc, id=id)
        return id


    def item_delete(self, id: str, all: bool = True, recur: bool = False, lazy: bool = False):
        '''Deletes item from items database.
        
        id: The UUID of item to delete.
        all: If true, also deletes item's container and file docs.
        lazy: If true, won't error if document doesn't exist.
        '''
        self.db.document_delete(dbname="items", id=id, lazy=lazy)
        if recur == True:
            all_children = self.container_children_all(container=id, result="ITEM")
            self.items_delete(ids=all_children, all=all, recur=False, lazy=True)
        if all == True:
            children = self.container_children(container=id, result="CON")
            parents = self.item_parents(item=id, result="CON")
            self.db.documents_delete(dbname="containers", ids=children+parents, lazy=lazy)


    def item_edit(self, id: str, data: dict, lazy: bool = False):
        '''Edits item in items database.
        
        id: The UUID of item to edit.
        data: Dictionary of fields+values to adjust.
        lazy: If true, won't error if document doesn't exist.
        '''
        self.db.document_edit(dbname="items", id=id, doc=data, lazy=lazy)


    def item_exists(self, id: str):
        '''Returns whether or not an item exists.
        
        id: The UUID of item to check.
        '''
        return self.db.document_exists(dbname="items", id=id)


    def item_flag(self, item: str, flag: str, value: int, lazy: bool = False):
        '''Sets a flag for an item to a particular value.
        
        item: Item to set flag for.
        flag: Flag to set.
        value: Numerical value to set flag to.
        lazy: If true, won't error if item doesn't exist.
        '''
        self.db.document_edit(dbname="items", doc={flag: value}, id=item, lazy=lazy)


    def item_get(self, id: str, fields: list = None, lazy: bool = False):
        '''Retrieves item from items database.
        
        id: The UUID of item to retrieve.
        fields: If included, only returns listed fields.
        lazy: If true, won't error if document doesn't exist.
        '''
        doc = self.db.document_get(dbname="items", id=id, lazy=lazy)
        if fields != None:
            doc = {field: doc.get(field, "") for field in fields}
        return doc


    def item_parents(self, item: str, cat: str = None, result: str = "ITEM"):
        '''Returns flat list, listing items containing an item.

        item: Item to return containing containers of.
        cat: If included, only returns parents of this category.
        result: "ITEM" to return item ids, "CON" to return container ids, "DOC" to return item documents.
        '''
        selector = {'child': {'$eq': item}}
        fields = ['_id', 'container']
        sort = [{'child': 'asc'}, {'container': 'asc'}]
        query = self.containers_query(selector=selector, fields=fields, sort=sort)
        if result == "CON":
            parents = [row['_id'] for row in query if cat == None or self.id_cat(row['container']) == cat]
        elif result == "ITEM" or result == "DOC":
            parents = [row['container'] for row in query if cat == None or self.id_cat(row['container']) == cat]
            if result == "DOC":
                parents = self.db.documents_get(dbname="items", ids=parents)
        else:
            raise ValueError("result should be one of ITEM, CON or DOC")
        return parents


    def item_parents_all(self, item: str, cat: str = None, result: str = "ITEM"):
        '''Returns flat list, listing all items containing an item, recursively.

        item: Item to return containing containers of.
        cat: If included, only returns parents of this category.
        result: "ITEM" to return item ids, "CON" to return container ids, "DOC" to return item documents.
        '''
        return self.items_parents_all(items=[item], cat=cat, result=result)


    def item_parents_all_dict(self, item: str, cat: str = None):
        '''Returns nested dictionary, listing all items containing an item, recursively.
        
        item: Item to return containing containers of.
        cat: If included, only returns parents of this category.
        '''
        return self.items_parents_all_dict(items=[item], cat=cat)


    def item_parents_dict(self, item: str, cat: str = None):
        '''Returns dictionary, listing items containing an item.

        item: Item to return containing containers of.
        cat: If included, only returns parents of this category.
        '''
        parents = {item: self.item_parents(item=item, cat=cat)}
        return parents


    def items_create(self, cat: str, docs: list):
        '''Creates multiple new items at once, returns ids.
        
        cat: The items' category.
        docs: The items' data: [{"field": "value", ...}, {"field": "value", ...}, ...]
        '''
        ids = self.db.id_create(n=len(docs), length=self.id_len, prefix=cat+"/")
        new_docs = []
        for doc in docs:
            doc_c = doc.copy()
            doc_c['category'] = cat
            new_docs.append(doc_c)
        self.db.documents_create(dbname="items", docs=new_docs, ids=ids)
        return ids


    def items_delete(self, ids: list, all: bool = True, recur: bool = False, lazy: bool = False):
        '''Deletes multiple items at once, returns ids.
        
        ids: The UUIDs of items to delete.
        all: If true, also deletes items' container and file docs.
        lazy: If true, won't error if document doesn't exist.
        '''
        self.db.documents_delete(dbname="items", ids=ids, lazy=lazy)
        if recur == True:
            all_children = self.containers_children(containers=ids, result="ITEM")
            self.items_delete(ids=all_children, all=all, recur=False, lazy=True)
        if all == True:
            children = self.containers_children(containers=ids, result="CON")
            parents = self.items_parents(items=ids, result="CON")
            self.db.documents_delete(dbname="containers", ids=children+parents, lazy=lazy)


    def items_edit(self, ids: list, data: list, lazy: bool = False):
        '''Edits multiple items at once.
        
        ids: The UUID of item to edit.
        data: Dictionary of fields+values to adjust.
        lazy: If true, won't error if document doesn't exist.
        '''
        self.db.documents_edit(dbname="items", ids=ids, docs=data, lazy=lazy)


    def items_flag(self, items: list, flag: str, value: int, lazy: bool = False):
        '''Sets a flag for multiple items to a particular value.
        
        items: Items to set flag for.
        flag: Flag to set.
        value: Numerical value to set flag to.
        lazy: If true, won't error if item doesn't exist.
        '''
        self.db.documents_edit(dbname="items", docs=[{flag: value}]*len(items), ids=items, lazy=lazy)


    def items_get(self, ids: list, fields: list = None, lazy: bool = False):
        '''Retrieves multiple items at once.
        
        ids: The UUIDs of items to retrieve.
        fields: If included, only returns listed fields.
        lazy: If true, won't error if any documents don't exist.
        '''
        docs = self.db.documents_get(dbname="items", ids=ids, lazy=lazy)
        if fields != None:
            new_docs = []
            for doc in docs:
                doc = {field: doc.get(field, "") for field in fields}
                new_docs.append(doc)
            docs = new_docs
        return docs


    def items_list(self, cat: str = None, fields: list = None):
        '''Retrieves every item in a category from items database. Intensive!
        
        cat: Category to return. If omitted, returns all categories.
        fields: If included, only returns listed fields.
        '''
        if cat == None:
            startkey = None
            endkey = None
        else:
            startkey = cat+"/"+self.id_len*"0"
            endkey = cat+"/"+self.id_len*"f"
        docs = self.db.documents_list(dbname="items", startkey=startkey, endkey=endkey, limit=self.limit)
        if fields != None:
            new_docs = []
            for doc in docs:
                new_doc = {field: doc.get(field, "") for field in fields}
                new_docs.append(new_doc)
            return new_docs
        else:
            return docs


    def items_parents(self, items: list, cat: str = None, result: str = "ITEM"):
        '''Returns flat list, listing items containing one of multiple items.

        items: Items to return containing containers of.
        cat: If included, only returns parents of this category.
        result: "ITEM" to return item ids, "CON" to return container ids, "DOC" to return item documents.
        '''
        selector = {'child': {'$in': items}}
        fields = ['_id', 'container']
        sort = [{'child': 'asc'}, {'container': 'asc'}]
        query = self.containers_query(selector=selector, fields=fields, sort=sort)
        if result == "CON":
            parents = [row['_id'] for row in query if cat == None or self.id_cat(row['container']) == cat]
            parents = list(dict.fromkeys(parents))
        elif result == "ITEM" or result == "DOC":
            parents = [row['container'] for row in query if cat == None or self.id_cat(row['container']) == cat]
            parents = list(dict.fromkeys(parents))
            if result == "DOC":
                parents = self.db.documents_get(dbname="items", ids=parents)
        else:
            raise ValueError("result should be one of ITEM, CON or DOC")
        return parents


    def items_parents_all(self, items: str, cat: str = None, result: str = "ITEM"):
        '''Returns flat list, listing all items containing one of multiple items, recursively.
        
        items: Items to return containing containers of.
        cat: If included, only returns parents of this category.
        result: "ITEM" to return item ids, "CON" to return container ids, "DOC" to return item documents.
        '''
        parents = []
        current_containers = items
        while True:
            ids = self.items_parents(items=current_containers, result="ITEM")
            if len(ids) > 0:
                parents += self.items_parents(items=current_containers, result=result, cat=cat)
                current_containers = ids
            else:
                break
        return parents


    def items_parents_all_dict(self, items: str, cat: str = None):
        '''Returns nested dictionary, listing all items containing one of multiple items, recursively.
        
        items: Items to return containing containers of.
        cat: If included, only returns parents of this category.
        '''
        results = self.items_parents_dict(items=items)
        for item in items:
            result = results[item]
            if len(result) > 0:
                result = self.items_parents_all_dict(items=result, cat=cat)
            results[item] = result
        if cat != None:
            results_c = results.copy()
            for result in results_c:
                if len(results[result]) == 0 and self.id_cat(result) != cat:
                    del results[result]
        return results


    def items_parents_dict(self, items: list, cat: str = None):
        '''Returns nested dictionary, listing items containing one of multiple items.

        items: Items to return containing containers of.
        cat: If included, only returns parents of this category.
        '''
        selector = {'child': {'$in': items}}
        fields = ['_id', 'container', 'child']
        sort = [{'child': 'asc'}, {'container': 'asc'}]
        query = self.containers_query(selector=selector, fields=fields, sort=sort)
        parents = {item: [] for item in items}
        for row in query:
            parent = row['container']
            if cat == None or self.id_cat(parent) == cat:
                parents[row['child']].append(parent)
        return parents


    def items_query(self, cat: str = None, selector: dict = {}, fields: list = None, sort: list = None):
        '''Queries the item database and returns the results.

        For selector operators, see: https://docs.mongodb.com/manual/reference/operator/query/

        cat = Category to query. If omitted, checks all categories.
        selector = A MongoDB style selector: {"FIELDNAME" : {"OPERATOR": "VALUE"}, ... }. If omitted, returns all items.
        fields = List of fields to return: ["FIELD1", "FIELD2", ...]. If omitted, returns all fields.
        sort = List defining sort order: [{"FIELD1": "ASC"}, {"FIELD2": "DESC"}, ...]. If omitted, returns in ascending UUID order.
        '''
        if cat != None:
            selector['category'] = {"$eq": cat}
        else:
            selector['category'] = {"$ne": ""}
        if sort != None:
            index_name = "idx"
            for field in sort:
                key = next(iter(field.keys()))
                index_name += f"-{key}"
            if self.db.index_exists(dbname="items", name=index_name) == False:
                self.db.index_create(dbname="items", name=index_name, fields=sort)
        res = self.db.query(dbname="items", selector=selector, fields=fields, sort=sort, limit=self.limit)
        return res


    def schema_fields(self, *, cat: str = None, id: str = None):
        '''Returns the list of fields for a particular kind of item.

        Only cat OR id needs to be provided. If both, cat is used.

        cat: Category of item to recieve fields of.
        id: ID of item to recieve fields of.
        '''
        if cat == None:
            cat = self.id_cat(id=id)
        return self.schema[cat]["fields"]


    def schema_keys(self, *, cat: str = None, id: str = None):
        '''Returns the list of key fields for a particular kind of item.

        Only cat OR id needs to be provided. If both, cat is used.
        
        cat: Category of item to recieve key fields of.
        id: ID of item to recieve key fields of.
        '''
        if cat == None:
            cat = self.id_cat(id=id)
        return self.schema[cat]["keys"]


    def schema_load(self, schema: str = None, forcelocal: bool = False):
        '''Loads database schema into memory.

        Will look for doc "schema" in db "items" first, then locally.
        
        schema: Path to local .json file containing database schema.
        forcelocal: If true, uses local schema over one stored in the database.
        '''
        if forcelocal == False and self.db.document_exists(dbname="items", id="schema") == True:
            loaded_schema = self.db.document_get(dbname="items", id="schema")
        else:
            with open(schema, "r") as f:
                loaded_schema = json.loads(f.read())
        for key, value in self.schema.items():
            if "/" in key:
                raise ValueError("Category names cannot contain / chars.")
                # ...because they're used in UUIDs to split category from number
            if "category" in value["fields"]:
                raise ValueError("category can't be a field name.")
                # ...because it's reserved by app for identifying item types
        self.schema = loaded_schema


    def schema_name(self, doc: dict, *, cat: str = None, id: str = None):
        '''Takes doc, returns simple list of key field values.

        Priority for determining category: doc, then cat, then id.
        
        doc: The doc to get key values of.
        cat: Category name, if not in doc itself.
        id: Doc's UUID, if not in doc itself.
        '''
        if "category" in doc:
            keys = self.schema_keys(cat=doc["category"])
        elif "_id" in doc:
            keys = self.schema_keys(id=doc["_id"])
        elif cat != None:
            keys = self.schema_keys(cat=cat)
        else:
            keys = self.schema_keys(id=id)
        return [doc[key] for key in keys]


    def schema_save(self):
        '''Saves database schema to the database.'''
        if self.db.document_exists(dbname="items", id="schema"):
            self.db.document_edit(dbname="items", doc=self.schema, id="schema")
        else:
            self.db.document_create(dbname="items", doc=self.schema, id="schema")


# ----------------------------------------------------------------------------